# pragma pylint: disable=missing-module-docstring, invalid-name, pointless-string-statement
# flake8: noqa
# isort: skip_file

import logging
from dataclasses import dataclass
from datetime import datetime, timezone
from typing import Any, Optional, Tuple

import numpy as np
import pandas as pd
from pandas import DataFrame

from freqtrade.persistence import Trade
from freqtrade.strategy import DecimalParameter, IntParameter, IStrategy

logger = logging.getLogger(__name__)


@dataclass(frozen=True)
class _SafeDefaults:
    delay_min_default: int = 15
    delay_min_low: int = 10
    delay_min_high: int = 20
    kickoff_min_default: int = 5
    kickoff_min_low: int = 0
    kickoff_min_high: int = 15
    max_positions: int = 2


class AggroDelayKickoffMomentum(IStrategy):
    """
    공격적/테스트 목적 (Spot Long only)
    - 실행 후 delay(10~20분) 경과 전: 매수 절대 금지 (confirm_trade_entry에서 강제)
    - delay 경과 후 kickoff(기본 5분) 동안: 조건 거의 없이 매수 승인 -> "실제 주문" 확인용
    - kickoff 이후: 초단기 모멘텀 score >= threshold 일 때만 승인
    - 동시 보유 포지션 최대 2개 강제
    - 매수 금액: 잔고를 남은 슬롯 기준으로 자동 분배(가능하면) + reserve_ratio 버퍼
    """

    INTERFACE_VERSION = 3
    can_short = False

    timeframe = "1m"
    process_only_new_candles = True
    startup_candle_count = 50

    minimal_roi = {
        "0": 0.010,
        "10": 0.005,
        "30": 0.0,
    }

    stoploss = -0.25

    trailing_stop = True
    trailing_stop_positive = 0.003
    trailing_stop_positive_offset = 0.006
    trailing_only_offset_is_reached = True

    use_exit_signal = True
    exit_profit_only = False
    ignore_roi_if_entry_signal = True

    entry_delay_minutes = IntParameter(
        low=_SafeDefaults.delay_min_low,
        high=_SafeDefaults.delay_min_high,
        default=_SafeDefaults.delay_min_default,
        space="buy",
        optimize=False,
        load=True,
    )

    kickoff_minutes = IntParameter(
        low=_SafeDefaults.kickoff_min_low,
        high=_SafeDefaults.kickoff_min_high,
        default=_SafeDefaults.kickoff_min_default,
        space="buy",
        optimize=False,
        load=True,
    )

    score_threshold = DecimalParameter(
        low=-5.0,
        high=20.0,
        default=0.25,
        decimals=2,
        space="buy",
        optimize=False,
        load=True,
    )

    reserve_ratio = DecimalParameter(
        low=0.00,
        high=0.20,
        default=0.02,
        decimals=3,
        space="buy",
        optimize=False,
        load=True,
    )

    _start_utc: Optional[datetime] = None
    _delay_logged: bool = False

    # ---------- utils ----------
    @staticmethod
    def _to_utc(dt: datetime) -> datetime:
        try:
            if dt.tzinfo is None:
                return dt.replace(tzinfo=timezone.utc)
            return dt.astimezone(timezone.utc)
        except Exception:
            return datetime.now(timezone.utc)

    @staticmethod
    def _clamp_int(val: Any, low: int, high: int, default: int) -> int:
        try:
            i = int(val)
        except Exception:
            return default
        return max(low, min(high, i))

    @staticmethod
    def _clamp_float(val: Any, low: float, high: float, default: float) -> float:
        try:
            f = float(val)
            if np.isnan(f) or np.isinf(f):
                return default
        except Exception:
            return default
        return max(low, min(high, f))

    @staticmethod
    def _ensure_cols(df: DataFrame, cols: Tuple[str, ...]) -> None:
        for c in cols:
            if c not in df.columns:
                df[c] = np.nan

    @staticmethod
    def _ema(close: pd.Series, period: int) -> pd.Series:
        s = pd.to_numeric(close, errors="coerce")
        return s.ewm(span=period, adjust=False, min_periods=period).mean()

    @staticmethod
    def _rsi(close: pd.Series, period: int = 14) -> pd.Series:
        s = pd.to_numeric(close, errors="coerce")
        delta = s.diff()
        gain = delta.clip(lower=0.0)
        loss = (-delta).clip(lower=0.0)

        avg_gain = gain.ewm(alpha=1 / period, adjust=False, min_periods=period).mean()
        avg_loss = loss.ewm(alpha=1 / period, adjust=False, min_periods=period).mean()

        rs = avg_gain / avg_loss.replace(0.0, np.nan)
        rsi = 100.0 - (100.0 / (1.0 + rs))
        return rsi.replace([np.inf, -np.inf], np.nan).fillna(50.0)

    # ---------- callbacks ----------
    def bot_start(self, **kwargs) -> None:
        self._start_utc = datetime.now(timezone.utc)
        self._delay_logged = False

        d = _SafeDefaults()
        delay = self._clamp_int(getattr(self.entry_delay_minutes, "value", d.delay_min_default),
                                d.delay_min_low, d.delay_min_high, d.delay_min_default)
        kickoff = self._clamp_int(getattr(self.kickoff_minutes, "value", d.kickoff_min_default),
                                  d.kickoff_min_low, d.kickoff_min_high, d.kickoff_min_default)
        thr = self._clamp_float(getattr(self.score_threshold, "value", 0.25), -5.0, 20.0, 0.25)
        rr = self._clamp_float(getattr(self.reserve_ratio, "value", 0.02), 0.0, 0.2, 0.02)

        logger.warning(
            "[AggroDelayKickoffMomentum] start_utc=%s delay=%sm kickoff=%sm score_thr=%.2f reserve=%.3f",
            self._start_utc.isoformat(), delay, kickoff, thr, rr
        )

    def populate_indicators(self, dataframe: DataFrame, metadata: dict) -> DataFrame:
        try:
            if dataframe is None or dataframe.empty:
                return dataframe

            self._ensure_cols(dataframe, ("open", "high", "low", "close", "volume"))
            for c in ("open", "high", "low", "close", "volume"):
                dataframe[c] = pd.to_numeric(dataframe[c], errors="coerce")

            dataframe["ema_fast"] = self._ema(dataframe["close"], 9)
            dataframe["ema_slow"] = self._ema(dataframe["close"], 21)
            dataframe["rsi"] = self._rsi(dataframe["close"], 14)

            dataframe["roc_3"] = dataframe["close"].pct_change(3) * 100.0
            dataframe["roc_10"] = dataframe["close"].pct_change(10) * 100.0

            dataframe["vol_mean_30"] = dataframe["volume"].rolling(window=30, min_periods=1).mean()
            denom = dataframe["vol_mean_30"].replace(0.0, np.nan)
            dataframe["vol_spike"] = (dataframe["volume"] / denom).replace([np.inf, -np.inf], np.nan).fillna(1.0)

            ema_ratio = (dataframe["ema_fast"] / dataframe["ema_slow"]).replace([np.inf, -np.inf], np.nan).fillna(1.0)
            ema_edge = (ema_ratio - 1.0) * 100.0

            dataframe["score"] = (
                0.55 * dataframe["roc_3"].replace([np.inf, -np.inf], np.nan).fillna(0.0)
                + 0.25 * dataframe["roc_10"].replace([np.inf, -np.inf], np.nan).fillna(0.0)
                + 0.15 * ((dataframe["vol_spike"] - 1.0) * 10.0)
                + 0.05 * ema_edge.replace([np.inf, -np.inf], np.nan).fillna(0.0)
            )
            dataframe["score"] = dataframe["score"].replace([np.inf, -np.inf], np.nan).fillna(0.0)

            return dataframe

        except Exception as e:
            logger.exception("[populate_indicators] guarded error: %s", str(e))
            return dataframe

    def populate_entry_trend(self, dataframe: DataFrame, metadata: dict) -> DataFrame:
        try:
            if dataframe is None or dataframe.empty:
                return dataframe

            self._ensure_cols(dataframe, ("close", "volume"))

            dataframe["enter_long"] = 0
            dataframe["enter_tag"] = None

            cond = (dataframe["volume"] > 0) & (dataframe["close"].notna())
            dataframe.loc[cond, ["enter_long", "enter_tag"]] = (1, "candidate")

            return dataframe

        except Exception as e:
            logger.exception("[populate_entry_trend] guarded error: %s", str(e))
            return dataframe

    def populate_exit_trend(self, dataframe: DataFrame, metadata: dict) -> DataFrame:
        try:
            if dataframe is None or dataframe.empty:
                return dataframe

            self._ensure_cols(dataframe, ("volume", "rsi", "ema_fast", "ema_slow", "roc_3"))

            dataframe["exit_long"] = 0
            dataframe["exit_tag"] = None

            cond = (dataframe["volume"] > 0) & (
                (dataframe["rsi"] > 85.0)
                | (dataframe["ema_fast"] < dataframe["ema_slow"])
                | (dataframe["roc_3"] < -0.50)
            )
            dataframe.loc[cond, ["exit_long", "exit_tag"]] = (1, "fast_exit")

            return dataframe

        except Exception as e:
            logger.exception("[populate_exit_trend] guarded error: %s", str(e))
            return dataframe

    def custom_stake_amount(
        self,
        pair: str,
        current_time: datetime,
        current_rate: float,
        proposed_stake: float,
        min_stake: float | None,
        max_stake: float,
        leverage: float,
        entry_tag: str | None,
        side: str,
        **kwargs,
    ) -> float:
        try:
            d = _SafeDefaults()
            max_pos = d.max_positions

            try:
                open_count = int(Trade.get_open_trade_count())
            except Exception:
                open_count = 0

            remaining = max(1, max_pos - open_count)

            rr = self._clamp_float(getattr(self.reserve_ratio, "value", 0.02), 0.0, 0.2, 0.02)

            stake = float(proposed_stake)
            stake_currency = str(self.config.get("stake_currency", "USDT"))

            if getattr(self, "wallets", None):
                try:
                    free_amt = float(self.wallets.get_free(stake_currency))
                    per_slot = free_amt / float(remaining)
                    stake = min(stake, per_slot)
                except Exception:
                    stake = float(proposed_stake)

            stake = stake * (1.0 - rr)

            if np.isnan(stake) or np.isinf(stake) or stake <= 0:
                return float(proposed_stake)

            if min_stake is not None:
                ms = float(min_stake)
                if stake < ms:
                    stake = max(stake, ms)

            stake = min(stake, float(max_stake))
            return float(stake)

        except Exception as e:
            logger.exception("[custom_stake_amount] guarded error: %s", str(e))
            return float(proposed_stake)

    def confirm_trade_entry(
        self,
        pair: str,
        order_type: str,
        amount: float,
        rate: float,
        time_in_force: str,
        current_time: datetime,
        entry_tag: str | None,
        side: str,
        **kwargs,
    ) -> bool:
        try:
            d = _SafeDefaults()
            now_utc = self._to_utc(current_time)

            if self._start_utc is None:
                self._start_utc = datetime.now(timezone.utc)

            start_utc = self._to_utc(self._start_utc)

            delay_m = self._clamp_int(getattr(self.entry_delay_minutes, "value", d.delay_min_default),
                                      d.delay_min_low, d.delay_min_high, d.delay_min_default)
            kickoff_m = self._clamp_int(getattr(self.kickoff_minutes, "value", d.kickoff_min_default),
                                        d.kickoff_min_low, d.kickoff_min_high, d.kickoff_min_default)
            thr = self._clamp_float(getattr(self.score_threshold, "value", 0.25), -5.0, 20.0, 0.25)

            elapsed_sec = (now_utc - start_utc).total_seconds()

            # 1) delay 전: 진입 금지
            if elapsed_sec < (delay_m * 60):
                return False

            # 2) 동시 포지션 2개 강제
            try:
                open_count = int(Trade.get_open_trade_count())
            except Exception:
                open_count = 0
            if open_count >= d.max_positions:
                return False

            # delay 통과 로그 1회
            if not self._delay_logged:
                self._delay_logged = True
                logger.warning(
                    "[AggroDelayKickoffMomentum] delay passed: elapsed=%.1fs (delay=%sm)",
                    elapsed_sec, delay_m
                )

            # 3) kickoff 구간: 거의 무조건 승인(주문 테스트)
            if elapsed_sec < ((delay_m + kickoff_m) * 60):
                return True

            # 4) kickoff 이후: score 기반
            try:
                if not getattr(self, "dp", None):
                    return True

                df, _ = self.dp.get_analyzed_dataframe(pair=pair, timeframe=self.timeframe)
                if df is None or df.empty or "score" not in df.columns:
                    return True

                last_score = float(df["score"].iloc[-1])
                if np.isnan(last_score) or np.isinf(last_score):
                    return True

                return last_score >= thr

            except Exception:
                return True

        except Exception as e:
            logger.exception("[confirm_trade_entry] guarded error: %s", str(e))
            return False
