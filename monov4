# flake8: noqa
# isort: skip_file
# NOTE:
# - Spot (롱 only) 전제
# - 외부 네트워크 호출(예: requests) 금지
# - talib.abstract, numpy, pandas + freqtrade 내부 모듈만 사용

from __future__ import annotations

import numpy as np
import pandas as pd
from datetime import datetime, timedelta, timezone
from pandas import DataFrame
from typing import Any, Dict, Optional, Tuple

import talib.abstract as ta

from freqtrade.strategy import IStrategy, merge_informative_pair
from freqtrade.persistence import Trade, Order


def _clip01(x: pd.Series) -> pd.Series:
    return x.clip(lower=0.0, upper=1.0)


def _zscore(s: pd.Series, window: int) -> pd.Series:
    mu = s.rolling(window=window, min_periods=window).mean()
    sd = s.rolling(window=window, min_periods=window).std()
    return (s - mu) / (sd.replace(0.0, np.nan) + 1e-12)


class MonoQuantResearchV4Ultimate(IStrategy):
    """
    MonoQuantResearchV4Ultimate
    - Upbit KRW Spot (롱 only)
    - 멀티 레이어 레짐(시장(BTC) / 자산(ADX+기울기) / 미시(ATR%, 스파이크, 거래량 z-score, 유동성))
    - 신호는 score 기반(정규화) + 엔트리 3종(브레이크아웃/풀백/평균회귀)
    - custom_stake_amount: 변동성 타게팅(ATR%) + 레짐 기반 자동 축소/중단
    - custom_stoploss: 다단계 + ATR 기반(엔트리 태그별 계수 차등)
    - custom_exit: 1h 추세 붕괴, 레짐 전환, 변동성 급등, 시간 언클로그, 과열 청산
    - 주문 취소/만료(타임아웃) 시 30분 pair lock + 내부 cooldown 맵 저장 + (간단) 글로벌 세이프 모드
    """

    INTERFACE_VERSION = 3
    can_short = False

    timeframe = "5m"
    informative_timeframe = "1h"
    process_only_new_candles = True

    # 1h EMA200(200개) 확보를 5m 기준으로 넉넉히: 200시간 = 2400 * 5m
    startup_candle_count = 2500

    # Exit signal은 사용하되, 핵심 청산은 custom_exit + custom_stoploss
    use_exit_signal = True
    exit_profit_only = False
    ignore_roi_if_entry_signal = False
    minimal_roi: Dict[str, float] = {}

    # Hard max loss(연구용 안전장치): custom_stoploss는 이보다 악화되는 값은 사용되지 않도록 설계
    stoploss = -0.30
    use_custom_stoploss = True

    # ====== Informative(시장 레짐) ======
    btc_pair = "BTC/KRW"

    # ====== (A) BTC 시장 레짐 파라미터 ======
    btc_ema_fast = 50
    btc_ema_slow = 200
    btc_atr_len = 14
    btc_rsi_len = 14

    btc_vol_spike_mult = 1.8     # btc_atrp > btc_atrp_sma * mult 면 변동성 급등
    btc_atrp_sma_win = 48        # 48h
    btc_atrp_abs_max = 0.06      # 절대 상한(6%) 넘으면 신규진입 중단 성격

    # risk-on 조건(예시 기반 확장)
    btc_rsi_min = 45.0           # risk-on에서 최소 RSI
    btc_slope_min = 0.0          # EMA50 기울기(%)가 양수

    # ====== (B) 자산 레짐(5m) 파라미터 ======
    adx_len = 14
    adx_trend_min = 22.0         # 추세장 판단
    adx_range_max = 18.0         # 횡보장 판단
    slope_atr_min = 0.08         # EMA50 slope를 ATR로 정규화한 최소치(추세 기울기)

    # ====== (C) 미시 레짐(품질/체결 위험) ======
    atr_len = 14
    atrp_min = 0.0015            # 0.15% 미만 = 죽은장(신규진입 회피)
    atrp_max = 0.0300            # 3% 초과 = 과도 변동(신규진입 회피)
    atrp_sma_win = 96            # 8h
    atrp_spike_mult = 2.2        # 개별 페어 변동성 급등 감지

    gap_pct_max = 0.020          # 이전 종가 대비 갭(2%)
    range_pct_max = 0.040        # (high-low)/close 4% 이상 = 스파이크(가격 품질 나쁨)
    vol_z_win = 48               # 4h
    vol_z_min = 0.6              # 엔트리 기본 거래량 컨펌
    vol_z_spike_max = 4.5        # "슬리피지 위험"(급격 거래대금 폭증) 구간 회피

    # 유동성: 1시간 누적 거래대금(근사) 하한
    min_qvol_1h_krw = 15_000_000.0

    # 과열 필터
    rsi_len = 14
    rsi_overheat = 76.0          # 과열 구간 신규진입 회피(특정 엔트리 제외)

    # ====== Donchian / BB ======
    donch_len = 24               # 2시간(5m*24)
    bb_len = 20
    bb_dev = 2.0

    # ====== Score 임계 ======
    score_breakout_th = 0.70
    score_pullback_th = 0.66
    score_meanrev_th = 0.62

    # ====== custom_stake (변동성 타게팅) ======
    base_stake_krw = 50_000.0            # 기본 KRW(전략 내부 기준)
    min_stake_safe_krw = 10_200.0        # 안전 버퍼 포함 최소 주문 하한(요구사항)
    atrp_target = 0.0080                  # 목표 변동성(0.8%)

    stake_clip_min = 0.20                 # vol targeting 최소 배수
    stake_clip_max = 2.20                 # vol targeting 최대 배수

    # 엔트리 타입별 배수(위험 정책)
    stake_mult_breakout = 1.00
    stake_mult_pullback = 0.85
    stake_mult_meanrev = 0.70

    # BTC risk-off 시 신규진입(스테이크 0으로 차단)
    stake_when_riskoff = 0.0

    # ====== 주문/세이프모드 ======
    # entry/exit limit 주문이 오래 미체결이면 취소 → 30분 pair lock
    entry_timeout_min = 6.0
    exit_timeout_min = 6.0
    lock_after_order_issue_min = 30.0

    # 주문 이슈(취소/만료 등) 누적 → 글로벌 세이프 모드(신규진입 중단)
    order_issue_window_min = 12.0
    order_issue_max = 5
    global_pause_min = 45.0

    # 스프레드 필터(가능하면): confirm_trade_entry에서 orderbook 1레벨로 계산
    enable_spread_filter = True
    spread_max_pct = 0.0025                  # 0.25%
    spread_max_atrp_mult = 0.45              # 허용 스프레드 <= atrp * 계수
    spread_cache_sec = 25

    # ====== custom_exit 규칙 ======
    unclog_hours = 6.0
    unclog_profit_band = 0.008       # ±0.8% 이내면 '정체'로 간주
    post_exit_lock_min = 20.0        # custom_exit 발동 시 재진입 방지용 추가 락(보조)

    # Mean Reversion 청산(과열/채널 상단)
    mr_exit_rsi = 68.0

    # ====== custom_stoploss (다단계 + ATR 기반) ======
    # open 대비 기준 손절폭(ATR% 기반) 최소/최대
    sl_open_min = 0.020
    sl_open_max = 0.140

    # 엔트리 타입별 손절 계수(ATR% * 계수)
    sl_atrp_mult_breakout = 5.8
    sl_atrp_mult_pullback = 5.2
    sl_atrp_mult_meanrev = 4.4

    # 브레이크이븐/트레일 단계
    sl_be_profit = 0.012           # 1.2% 이익부터 BE 근처로 당김
    sl_be_open_rel = -0.006        # open 대비 -0.6% 근처(수수료/슬리피지 여유)
    sl_trail_start = 0.030         # 3%부터 트레일 본격화
    sl_trail_atrp_mult = 3.4       # 트레일 거리 = atrp * 계수
    sl_trail_min = 0.012
    sl_trail_max = 0.060

    # ====== 내부 상태 ======
    def bot_start(self, **kwargs: Any) -> None:
        self._pair_cooldown_until: Dict[str, datetime] = {}
        self._order_issue_times: list[datetime] = []
        self._global_pause_until: Optional[datetime] = None
        self._spread_cache: Dict[str, Tuple[datetime, float]] = {}
        self._loss_streak: Dict[str, int] = {}
        self._last_sanity_gc: Optional[datetime] = None

    # ====== 보호장치(protections) ======
    @property
    def protections(self):
        # CooldownPeriod / StoplossGuard / MaxDrawdown 포함(요구사항)
        return [
            {
                "method": "CooldownPeriod",
                "stop_duration_candles": 12,     # 5m*12=60분
            },
            {
                "method": "StoplossGuard",
                "lookback_period_candles": 288,  # 24시간(5m)
                "trade_limit": 3,
                "stop_duration_candles": 144,    # 12시간
                "only_per_pair": False,
            },
            {
                "method": "MaxDrawdown",
                "lookback_period_candles": 288,  # 24시간
                "trade_limit": 10,
                "stop_duration_candles": 288,    # 24시간
                "max_allowed_drawdown": 0.20,    # 20%
            },
        ]

    # ====== Informative pairs ======
    def informative_pairs(self):
        pairs = []
        if self.dp:
            try:
                pairs = self.dp.current_whitelist()
            except Exception:
                pairs = []
        inf = [(p, self.informative_timeframe) for p in pairs]
        inf.append((self.btc_pair, self.informative_timeframe))
        # 중복 제거
        return list(dict.fromkeys(inf))

    # ====== 내부 유틸: pair lock (tz-aware UTC 강제) ======
    def _lock_pair_safe(self, pair: str, until: datetime, reason: str) -> None:
        try:
            if until.tzinfo is None:
                until = until.replace(tzinfo=timezone.utc)
            else:
                until = until.astimezone(timezone.utc)
            # lock_pair는 UTC tz-aware datetime 권장
            self.lock_pair(pair, until, reason=reason, side="long")
            self._pair_cooldown_until[pair] = until
        except Exception as e:
            # lock 실패는 전략이 죽지 않도록 흡수
            try:
                self.logger.warning(f"[lock_pair_safe] failed pair={pair} reason={reason} err={e}")
            except Exception:
                pass

    def _is_pair_cooldown(self, pair: str, current_time: datetime) -> bool:
        u = self._pair_cooldown_until.get(pair)
        if not u:
            return False
        # current_time은 tz-aware로 들어오는 것을 전제로(naive 들어오면 UTC로 간주)
        if current_time.tzinfo is None:
            ct = current_time.replace(tzinfo=timezone.utc)
        else:
            ct = current_time.astimezone(timezone.utc)
        return ct < u

    def _note_order_issue(self, current_time: datetime) -> None:
        # 주문 취소/만료/실패성 이벤트를 시간창으로 누적 → 글로벌 세이프 모드
        if current_time.tzinfo is None:
            ct = current_time.replace(tzinfo=timezone.utc)
        else:
            ct = current_time.astimezone(timezone.utc)

        self._order_issue_times.append(ct)
        cutoff = ct - timedelta(minutes=self.order_issue_window_min)
        self._order_issue_times = [t for t in self._order_issue_times if t >= cutoff]

        if len(self._order_issue_times) >= self.order_issue_max:
            self._global_pause_until = ct + timedelta(minutes=self.global_pause_min)

    def _global_pause_active(self, current_time: datetime) -> bool:
        if not self._global_pause_until:
            return False
        ct = current_time if current_time.tzinfo else current_time.replace(tzinfo=timezone.utc)
        ct = ct.astimezone(timezone.utc)
        return ct < self._global_pause_until

    # ====== (선택) 스프레드 필터 ======
    def _get_spread_pct_cached(self, pair: str, current_time: datetime) -> Optional[float]:
        if not self.enable_spread_filter or not self.dp:
            return None
        try:
            ct = current_time if current_time.tzinfo else current_time.replace(tzinfo=timezone.utc)
            ct = ct.astimezone(timezone.utc)

            cached = self._spread_cache.get(pair)
            if cached:
                ts, sp = cached
                if (ct - ts).total_seconds() <= float(self.spread_cache_sec):
                    return sp

            ob = self.dp.orderbook(pair, 1)
            bid = float(ob["bids"][0][0]) if ob.get("bids") else np.nan
            ask = float(ob["asks"][0][0]) if ob.get("asks") else np.nan
            if not np.isfinite(bid) or not np.isfinite(ask) or bid <= 0 or ask <= 0:
                return None
            mid = (bid + ask) / 2.0
            sp = (ask - bid) / mid
            self._spread_cache[pair] = (ct, sp)
            return sp
        except Exception:
            return None

    # ====== populate_indicators ======
    def populate_indicators(self, dataframe: DataFrame, metadata: dict) -> DataFrame:
        if dataframe is None or dataframe.empty:
            return dataframe

        df = dataframe

        # --- 기본 지표(5m) ---
        df["ema20"] = ta.EMA(df, timeperiod=20)
        df["ema50"] = ta.EMA(df, timeperiod=50)
        df["ema200"] = ta.EMA(df, timeperiod=200)

        df["rsi"] = ta.RSI(df, timeperiod=self.rsi_len)
        df["adx"] = ta.ADX(df, timeperiod=self.adx_len)

        df["atr"] = ta.ATR(df, timeperiod=self.atr_len)
        df["atrp"] = (df["atr"] / df["close"]).replace([np.inf, -np.inf], np.nan)

        # 변동성 레벨/스파이크
        df["atrp_sma"] = df["atrp"].rolling(window=self.atrp_sma_win, min_periods=self.atrp_sma_win).mean()
        df["vol_spike_pair"] = (df["atrp"] > (df["atrp_sma"] * self.atrp_spike_mult))

        # 스파이크/갭(가격 품질)
        df["gap_pct"] = (df["close"] / df["close"].shift(1) - 1.0).abs()
        df["range_pct"] = (df["high"] - df["low"]) / df["close"]

        # 거래대금 근사(KRW): base volume * close
        df["qvol_krw"] = (df["volume"] * df["close"]).astype("float64")
        df["qvol_1h_krw"] = df["qvol_krw"].rolling(window=12, min_periods=12).sum()
        df["qvol_z"] = _zscore(df["qvol_krw"], window=self.vol_z_win)

        # Donchian channel
        df["donch_high"] = df["high"].rolling(window=self.donch_len, min_periods=self.donch_len).max()
        df["donch_low"] = df["low"].rolling(window=self.donch_len, min_periods=self.donch_len).min()
        df["donch_high_prev"] = df["donch_high"].shift(1)
        df["donch_low_prev"] = df["donch_low"].shift(1)

        # Bollinger Bands
        bb = ta.BBANDS(df, timeperiod=self.bb_len, nbdevup=self.bb_dev, nbdevdn=self.bb_dev, matype=0)
        df["bb_upper"] = bb["upperband"]
        df["bb_mid"] = bb["middleband"]
        df["bb_lower"] = bb["lowerband"]
        df["bb_width"] = (df["bb_upper"] - df["bb_lower"]) / df["bb_mid"]

        # EMA slope (ATR 정규화)
        df["ema50_slope"] = df["ema50"] - df["ema50"].shift(1)
        df["ema50_slope_atr"] = df["ema50_slope"] / (df["atr"].replace(0.0, np.nan) + 1e-12)

        # --- 자산 레짐(추세/횡보) ---
        df["regime_trend"] = (
            (df["adx"] >= self.adx_trend_min) &
            (df["ema50_slope_atr"] >= self.slope_atr_min)
        )

        df["regime_range"] = (df["adx"] <= self.adx_range_max)

        # --- 미시 레짐(품질) ---
        df["micro_ok"] = (
            (df["atrp"] >= self.atrp_min) &
            (df["atrp"] <= self.atrp_max) &
            (df["gap_pct"] <= self.gap_pct_max) &
            (df["range_pct"] <= self.range_pct_max) &
            (df["qvol_1h_krw"] >= self.min_qvol_1h_krw) &
            (df["qvol_z"].fillna(-999) >= -1.0) &  # 극단적 저유동(음의 z) 회피
            (df["qvol_z"].fillna(0.0) <= self.vol_z_spike_max)  # 급격 거래대금 폭증 회피
        )

        # 과열 신규진입 회피(공통 가드)
        df["heat_ok"] = (df["rsi"] <= self.rsi_overheat)

        # --- (1h) 현재 페어 informative ---
        if self.dp:
            try:
                inf = self.dp.get_pair_dataframe(pair=metadata["pair"], timeframe=self.informative_timeframe).copy()
                inf["ema200"] = ta.EMA(inf, timeperiod=200)
                inf["ema50"] = ta.EMA(inf, timeperiod=50)
                inf["rsi"] = ta.RSI(inf, timeperiod=14)
                inf["atr"] = ta.ATR(inf, timeperiod=14)
                inf["atrp"] = (inf["atr"] / inf["close"]).replace([np.inf, -np.inf], np.nan)

                inf["ema50_slope"] = (inf["ema50"] - inf["ema50"].shift(1)) / (inf["ema50"].shift(1) + 1e-12)

                # merge (ffill=False로 안정성 확보) 후, _1h 컬럼에 한해 ffill
                df = merge_informative_pair(df, inf, self.timeframe, self.informative_timeframe, ffill=False)

                oneh_cols = [c for c in df.columns if c.endswith("_1h")]
                if oneh_cols:
                    df[oneh_cols] = df[oneh_cols].ffill()

            except Exception as e:
                try:
                    self.logger.warning(f"[inf_1h_merge] failed pair={metadata.get('pair')} err={e}")
                except Exception:
                    pass

        # --- (1h) BTC/KRW 시장 레짐: 수동 merge_asof (컬럼 충돌 방지) ---
        df = df.sort_values("date").reset_index(drop=True)
        if self.dp:
            try:
                btc = self.dp.get_pair_dataframe(pair=self.btc_pair, timeframe=self.informative_timeframe).copy()
                btc = btc.sort_values("date").reset_index(drop=True)

                btc["btc_close_1h"] = btc["close"]
                btc["btc_ema200_1h"] = ta.EMA(btc, timeperiod=self.btc_ema_slow)
                btc["btc_ema50_1h"] = ta.EMA(btc, timeperiod=self.btc_ema_fast)
                btc["btc_rsi_1h"] = ta.RSI(btc, timeperiod=self.btc_rsi_len)
                btc["btc_atr_1h"] = ta.ATR(btc, timeperiod=self.btc_atr_len)
                btc["btc_atrp_1h"] = (btc["btc_atr_1h"] / btc["btc_close_1h"]).replace([np.inf, -np.inf], np.nan)
                btc["btc_atrp_sma_1h"] = btc["btc_atrp_1h"].rolling(
                    window=self.btc_atrp_sma_win, min_periods=self.btc_atrp_sma_win
                ).mean()
                btc["btc_ema50_slope_1h"] = (btc["btc_ema50_1h"] - btc["btc_ema50_1h"].shift(1)) / (
                    btc["btc_ema50_1h"].shift(1) + 1e-12
                )

                # 1h는 "완성 캔들"만 쓰기 위해 shift(1)
                cols = [
                    "btc_close_1h",
                    "btc_ema200_1h",
                    "btc_ema50_1h",
                    "btc_rsi_1h",
                    "btc_atrp_1h",
                    "btc_atrp_sma_1h",
                    "btc_ema50_slope_1h",
                ]
                btc[cols] = btc[cols].shift(1)

                btc_small = btc[["date"] + cols].copy()

                # asof merge: 5m 캔들에 대해 직전 1h 지표 적용
                df = pd.merge_asof(
                    df,
                    btc_small,
                    on="date",
                    direction="backward",
                    allow_exact_matches=True,
                )

            except Exception as e:
                try:
                    self.logger.warning(f"[btc_1h_merge] failed err={e}")
                except Exception:
                    pass

        # --- BTC 레짐 계산 (NaN이면 False) ---
        btc_valid = (
            df["btc_close_1h"].notna() &
            df["btc_ema200_1h"].notna() &
            df["btc_ema50_1h"].notna()
        )

        df["btc_vol_spike"] = btc_valid & (
            (df["btc_atrp_1h"] > (df["btc_atrp_sma_1h"] * self.btc_vol_spike_mult)) |
            (df["btc_atrp_1h"] > self.btc_atrp_abs_max)
        )

        df["btc_risk_on"] = btc_valid & (
            (df["btc_close_1h"] > df["btc_ema200_1h"]) &
            (df["btc_ema50_slope_1h"] > self.btc_slope_min) &
            (df["btc_rsi_1h"] > self.btc_rsi_min) &
            (~df["btc_vol_spike"])
        )

        # --- (현재 페어) 1h 레짐 계산 ---
        oneh_valid = df.get("ema200_1h", pd.Series(index=df.index, data=np.nan)).notna() & df.get("close_1h", pd.Series(index=df.index, data=np.nan)).notna()
        df["pair_1h_up"] = oneh_valid & (
            (df["close_1h"] > df["ema200_1h"]) &
            (df.get("ema50_slope_1h", 0.0) > 0.0)
        )

        df["pair_1h_break"] = oneh_valid & (
            (df["close_1h"] < df["ema200_1h"]) |
            (df.get("ema50_slope_1h", 0.0) < 0.0)
        )

        # ====== Score(정규화) ======
        # 공통 component (trend/momentum/volatility/volume/structure 중 3개 이상을 score에 포함)
        # trend_norm: ema50_slope_atr
        trend_norm = _clip01((df["ema50_slope_atr"] - self.slope_atr_min) / (self.slope_atr_min + 0.20))
        mom_up_norm = _clip01((df["rsi"] - 50.0) / 20.0)             # 상승 모멘텀
        mom_os_norm = _clip01((50.0 - df["rsi"]) / 20.0)             # 과매도 강도(평균회귀/풀백용)
        vol_range_norm = _clip01((df["atrp"] - self.atrp_min) / (self.atrp_target - self.atrp_min + 1e-12))
        volm_norm = _clip01((df["qvol_z"] - self.vol_z_min) / (3.0)) # z-score 기반
        # structure_norm: 채널/밴드 관계를 ATR로 정규화
        struct_breakout = _clip01((df["close"] - df["donch_high_prev"]) / (df["atr"] + 1e-12))
        struct_pullback = _clip01((df["bb_lower"] - df["close"]) / (df["atr"] + 1e-12))  # 깊은 되돌림일수록 클수록
        struct_meanrev = _clip01((df["bb_mid"] - df["close"]) / (df["atr"] + 1e-12))

        # Trend Breakout score
        df["score_breakout"] = (
            0.30 * trend_norm +
            0.20 * mom_up_norm +
            0.20 * volm_norm +
            0.15 * vol_range_norm +
            0.15 * struct_breakout
        ).clip(0.0, 1.0)

        # Trend Pullback score
        df["score_pullback"] = (
            0.28 * trend_norm +
            0.28 * mom_os_norm +
            0.16 * volm_norm +
            0.12 * vol_range_norm +
            0.16 * struct_pullback
        ).clip(0.0, 1.0)

        # Mean Reversion score
        df["score_meanrev"] = (
            0.20 * (1.0 - trend_norm) +
            0.30 * mom_os_norm +
            0.20 * vol_range_norm +
            0.10 * volm_norm +
            0.20 * struct_meanrev
        ).clip(0.0, 1.0)

        # --- 레짐 전환 감지(청산/진입 제한에 사용 가능) ---
        df["btc_risk_on_prev"] = df["btc_risk_on"].shift(1).fillna(False)
        df["btc_riskoff_switch"] = (df["btc_risk_on_prev"] == True) & (df["btc_risk_on"] == False)

        df["trend_to_range_switch"] = (df["regime_trend"].shift(1).fillna(False) == True) & (df["regime_range"] == True)

        return df

    # ====== populate_entry_trend ======
    def populate_entry_trend(self, dataframe: DataFrame, metadata: dict) -> DataFrame:
        df = dataframe
        if df is None or df.empty:
            return df

        df["enter_long"] = 0
        df["enter_tag"] = ""

        # 공통 가드: 시장(BTC) risk-on + 변동성 스파이크 없음 + 미시 품질 OK + 과열 회피
        market_ok = df["btc_risk_on"].fillna(False)
        quality_ok = df["micro_ok"].fillna(False)
        heat_ok = df["heat_ok"].fillna(False)

        # Donchian breakout: 직전 상단 돌파
        donch_break = (df["close"] > df["donch_high_prev"])

        # 거래량 컨펌
        vol_ok = (df["qvol_z"].fillna(-999) >= self.vol_z_min)

        # ----- (1) Trend Breakout (추세장 전용) -----
        cond_breakout = (
            market_ok &
            df["regime_trend"].fillna(False) &
            quality_ok &
            heat_ok &
            donch_break &
            vol_ok &
            (df["atrp"] >= max(self.atrp_min, 0.0020)) &
            (df["score_breakout"] >= self.score_breakout_th)
        )

        df.loc[cond_breakout, ["enter_long", "enter_tag"]] = (1, "TB_BREAKOUT")

        # ----- (2) Trend Pullback (추세장 내 되돌림) -----
        # 1h 상승 레짐 유지 + 5m 과매도(밴드 하단/RSI) + EMA20 회복 시점
        oversold = (df["close"] < df["bb_lower"]) | (df["rsi"] < 38.0)
        reclaim = (df["close"] > df["ema20"]) & (df["close"].shift(1) <= df["ema20"].shift(1))

        cond_pullback = (
            (df["enter_long"] == 0) &  # 우선순위: breakout 다음
            market_ok &
            df["pair_1h_up"].fillna(False) &
            df["regime_trend"].fillna(False) &
            quality_ok &
            oversold &
            reclaim &
            (df["score_pullback"] >= self.score_pullback_th)
        )

        df.loc[cond_pullback, ["enter_long", "enter_tag"]] = (1, "TP_PULLBACK")

        # ----- (3) Mean Reversion (횡보장 전용) -----
        # ADX 낮음 + BB 하단 이탈→복귀 + RSI 컨펌
        bb_reclaim = (df["close"] > df["bb_lower"]) & (df["close"].shift(1) < df["bb_lower"].shift(1))
        rsi_confirm = (df["rsi"] < 44.0) & (df["rsi"] > df["rsi"].shift(1))

        cond_meanrev = (
            (df["enter_long"] == 0) &
            market_ok &                          # 시장 리스크오프면 신규진입 자체를 custom_stake에서 차단
            df["regime_range"].fillna(False) &
            quality_ok &
            bb_reclaim &
            rsi_confirm &
            (df["score_meanrev"] >= self.score_meanrev_th)
        )

        df.loc[cond_meanrev, ["enter_long", "enter_tag"]] = (1, "MR_RANGE")

        return df

    # ====== populate_exit_trend (필수 구현) ======
    def populate_exit_trend(self, dataframe: DataFrame, metadata: dict) -> DataFrame:
        df = dataframe
        if df is None or df.empty:
            return df
        df["exit_long"] = 0
        df["exit_tag"] = ""
        return df

    # 구버전 호환: populate_sell_trend → exit_long 연결
    def populate_sell_trend(self, dataframe: DataFrame, metadata: dict) -> DataFrame:
        df = self.populate_exit_trend(dataframe, metadata)
        # 과거 컬럼도 같이 채워주되, 실제 사용은 exit_long 중심
        df["sell"] = df.get("exit_long", 0)
        df["sell_tag"] = df.get("exit_tag", "")
        return df

    # ====== custom_stake_amount (변동성 타게팅) ======
    def custom_stake_amount(
        self,
        pair: str,
        current_time: datetime,
        current_rate: float,
        proposed_stake: float,
        min_stake: float | None,
        max_stake: float,
        leverage: float,
        entry_tag: str | None,
        side: str,
        **kwargs: Any,
    ) -> float:
        # 글로벌 세이프 모드
        if self._global_pause_active(current_time):
            return 0.0

        # pair cooldown
        if self._is_pair_cooldown(pair, current_time) or self.is_pair_locked(pair):
            return 0.0

        # 동시 포지션 1개 제한(전략 방어) - DB 조회 실패시엔 보수적으로 제한하지 않음
        try:
            if Trade.get_open_trade_count() >= 1:
                return 0.0
        except Exception:
            pass

        # 지표 기반 sizing
        try:
            if not self.dp:
                return proposed_stake

            df, _ = self.dp.get_analyzed_dataframe(pair=pair, timeframe=self.timeframe)
            if df is None or df.empty:
                return 0.0

            last = df.iloc[-1].squeeze()

            # BTC risk-off / 변동성 급등 → 신규진입 중단(요구사항)
            btc_risk_on = bool(last.get("btc_risk_on", False))
            btc_vol_spike = bool(last.get("btc_vol_spike", False))
            if (not btc_risk_on) or btc_vol_spike:
                return float(self.stake_when_riskoff)

            # 미시 품질 필터(체결품질/죽은장/스파이크/유동성)
            if not bool(last.get("micro_ok", False)):
                return 0.0

            atrp = float(last.get("atrp", np.nan))
            if not np.isfinite(atrp) or atrp <= 0:
                return 0.0

            # 엔트리 타입별 base
            tag = (entry_tag or "").upper()
            base = float(self.base_stake_krw)
            if tag.startswith("TB_"):
                base *= float(self.stake_mult_breakout)
            elif tag.startswith("TP_"):
                base *= float(self.stake_mult_pullback)
            elif tag.startswith("MR_"):
                base *= float(self.stake_mult_meanrev)

            # Volatility Targeting: stake ∝ target_atrp / atrp
            vol_mult = float(self.atrp_target) / max(atrp, float(self.atrp_min))
            vol_mult = float(np.clip(vol_mult, float(self.stake_clip_min), float(self.stake_clip_max)))
            stake = base * vol_mult

            # 최소 주문 안전 버퍼(요구사항)
            if stake < float(self.min_stake_safe_krw):
                return 0.0

            # max_stake, min_stake로 클램프
            if min_stake is not None:
                stake = max(float(min_stake), float(stake))
            stake = min(float(max_stake), float(stake))

            return float(stake)

        except Exception as e:
            # 예외 시 proposed_stake로 폴백(전략 콜백 보수적 운영)
            try:
                self.logger.warning(f"[custom_stake_amount] fallback proposed_stake due to err={e}")
            except Exception:
                pass
            return float(proposed_stake)

    # ====== 주문 취소/만료 시: 30분 pair lock + cooldown 저장 ======
    def check_entry_timeout(
        self,
        pair: str,
        trade: Trade,
        order: Order,
        current_time: datetime,
        **kwargs: Any,
    ) -> bool:
        try:
            if self._global_pause_active(current_time):
                return True

            # trade/order None 방어(요구사항)
            if trade is None or order is None:
                self._note_order_issue(current_time)
                self._lock_pair_safe(pair, datetime.now(timezone.utc) + timedelta(minutes=self.lock_after_order_issue_min), "order_issue_entry_none")
                return True

            odt = order.order_date_utc
            if odt is None:
                # order 생성 시간이 없다면 보수적으로 오래된 것으로 취급하지 않음
                return False

            age_min = (current_time - odt).total_seconds() / 60.0
            if age_min >= float(self.entry_timeout_min):
                self._note_order_issue(current_time)
                self._lock_pair_safe(pair, datetime.now(timezone.utc) + timedelta(minutes=self.lock_after_order_issue_min), "order_timeout_entry")
                return True

            # 스파이크/변동성 급등 중엔 미체결 entry를 빠르게 정리
            if self.dp:
                df, _ = self.dp.get_analyzed_dataframe(pair=pair, timeframe=self.timeframe)
                if df is not None and not df.empty:
                    last = df.iloc[-1].squeeze()
                    if bool(last.get("vol_spike_pair", False)) or bool(last.get("btc_vol_spike", False)):
                        self._note_order_issue(current_time)
                        self._lock_pair_safe(pair, datetime.now(timezone.utc) + timedelta(minutes=self.lock_after_order_issue_min), "order_timeout_entry_volspike")
                        return True

            return False
        except Exception:
            return False

    def check_exit_timeout(
        self,
        pair: str,
        trade: Trade,
        order: Order,
        current_time: datetime,
        **kwargs: Any,
    ) -> bool:
        try:
            if trade is None or order is None:
                self._note_order_issue(current_time)
                self._lock_pair_safe(pair, datetime.now(timezone.utc) + timedelta(minutes=self.lock_after_order_issue_min), "order_issue_exit_none")
                return False  # exit는 가능한 유지(안전상)
            odt = order.order_date_utc
            if odt is None:
                return False
            age_min = (current_time - odt).total_seconds() / 60.0
            if age_min >= float(self.exit_timeout_min):
                self._note_order_issue(current_time)
                # exit 주문이 오래 걸려도 신규진입은 막기 위해 pair lock
                self._lock_pair_safe(pair, datetime.now(timezone.utc) + timedelta(minutes=self.lock_after_order_issue_min), "order_timeout_exit")
                return True
            return False
        except Exception:
            return False

    # ====== confirm_trade_entry: cooldown/spread/품질 체크 ======
    def confirm_trade_entry(
        self,
        pair: str,
        order_type: str,
        amount: float,
        rate: float,
        time_in_force: str,
        current_time: datetime,
        entry_tag: str | None,
        side: str,
        **kwargs: Any,
    ) -> bool:
        # 글로벌 세이프 모드
        if self._global_pause_active(current_time):
            return False

        # 내부 cooldown + PairLocks
        if self._is_pair_cooldown(pair, current_time) or self.is_pair_locked(pair):
            return False

        # 동시 포지션 1개 제한(전략 방어)
        try:
            if Trade.get_open_trade_count() >= 1:
                return False
        except Exception:
            pass

        # 스프레드 필터(가능하면)
        sp = self._get_spread_pct_cached(pair, current_time)
        if sp is not None and np.isfinite(sp):
            # atrp 기반 동적 허용치(더 변동성이 크면 약간 허용 확대)
            try:
                if self.dp:
                    df, _ = self.dp.get_analyzed_dataframe(pair=pair, timeframe=self.timeframe)
                    if df is not None and not df.empty:
                        atrp = float(df.iloc[-1].squeeze().get("atrp", 0.0))
                    else:
                        atrp = 0.0
                else:
                    atrp = 0.0
            except Exception:
                atrp = 0.0
            dyn = float(atrp) * float(self.spread_max_atrp_mult)
            limit = float(min(self.spread_max_pct, max(dyn, self.spread_max_pct * 0.6)))
            if sp > limit:
                return False

        return True

    # ====== order_filled: 연속 손실 감지 → 추가 쿨다운(StoplossGuard 외 추가 방어) ======
    def order_filled(
        self,
        pair: str,
        trade: Trade,
        order: Order,
        current_time: datetime,
        **kwargs: Any,
    ) -> None:
        try:
            if trade is None or order is None:
                return

            # exit(매도) 체결 시점에 손실 연속 여부 추정
            if getattr(order, "ft_order_side", "") in ("sell", "stoploss"):
                # trade.close_profit는 체결 직후 업데이트될 수 있음 (없으면 스킵)
                cp = getattr(trade, "close_profit", None)
                if cp is not None and np.isfinite(cp):
                    if float(cp) < 0:
                        self._loss_streak[pair] = int(self._loss_streak.get(pair, 0)) + 1
                    else:
                        self._loss_streak[pair] = 0

                    # 연속 2회 손실 → 추가 90분 락(강화 쿨다운)
                    if self._loss_streak.get(pair, 0) >= 2:
                        self._lock_pair_safe(
                            pair,
                            datetime.now(timezone.utc) + timedelta(minutes=90),
                            "loss_streak_lock",
                        )
        except Exception:
            return

    # ====== custom_stoploss: 다단계 + ATR 기반(엔트리 타입별) ======
    def custom_stoploss(
        self,
        pair: str,
        trade: Trade,
        current_time: datetime,
        current_rate: float,
        current_profit: float,
        after_fill: bool,
        **kwargs: Any,
    ) -> float | None:
        try:
            if trade is None or current_rate <= 0:
                return 1

            # 분석 DF에서 ATR% 가져오기(없으면 target 사용)
            atrp = float(self.atrp_target)
            if self.dp:
                df, _ = self.dp.get_analyzed_dataframe(pair=pair, timeframe=self.timeframe)
                if df is not None and not df.empty:
                    a = df.iloc[-1].squeeze().get("atrp", np.nan)
                    if np.isfinite(a) and float(a) > 0:
                        atrp = float(a)

            tag = (trade.enter_tag or "").upper()

            if tag.startswith("TB_"):
                k_open = float(self.sl_atrp_mult_breakout)
            elif tag.startswith("TP_"):
                k_open = float(self.sl_atrp_mult_pullback)
            elif tag.startswith("MR_"):
                k_open = float(self.sl_atrp_mult_meanrev)
            else:
                k_open = float(self.sl_atrp_mult_pullback)

            # open 대비 기본 손절 폭(ATR% 기반)
            base_open_loss = float(np.clip(atrp * k_open, float(self.sl_open_min), float(self.sl_open_max)))

            # 단계별 open-relative stop
            if current_profit < float(self.sl_be_profit):
                # 손절(손실/초기 구간): open 대비 -base
                open_rel_stop = -base_open_loss
            elif current_profit < float(self.sl_trail_start):
                # BE 근처로 당김
                open_rel_stop = float(self.sl_be_open_rel)
            else:
                # 트레일: 이익 - (ATR 기반 거리)
                trail_dist = float(np.clip(atrp * float(self.sl_trail_atrp_mult), float(self.sl_trail_min), float(self.sl_trail_max)))
                open_rel_stop = float(current_profit) - float(trail_dist)

            # Hard max loss(=self.stoploss)보다 더 큰 손실을 허용하지 않기
            open_rel_stop = max(float(open_rel_stop), float(self.stoploss))

            # open-relative stop → current-relative distance(양수, 0~1)
            stop_rate = float(trade.open_rate) * (1.0 + float(open_rel_stop))

            if stop_rate <= 0 or current_rate <= 0:
                return 1

            # stop_rate가 current_rate 이상이면 즉시 청산에 가까운 값(0) 반환
            dist = 1.0 - (stop_rate / float(current_rate))
            dist = float(max(dist, 0.0))

            # dist 상한(보수적): 0~abs(stoploss)
            dist = float(min(dist, abs(float(self.stoploss))))

            return dist
        except Exception:
            return 1

    # ====== custom_exit: 레짐 전환/추세 붕괴/시간 언클로그/과열 청산 ======
    def custom_exit(
        self,
        pair: str,
        trade: Trade,
        current_time: datetime,
        current_rate: float,
        current_profit: float,
        **kwargs: Any,
    ):
        if trade is None:
            return None

        try:
            if not self.dp:
                return None

            df, _ = self.dp.get_analyzed_dataframe(pair=pair, timeframe=self.timeframe)
            if df is None or df.empty:
                return None
            last = df.iloc[-1].squeeze()

            tag = (trade.enter_tag or "").upper()

            # (A) 1h 추세 붕괴 시 즉시 방어 청산
            if bool(last.get("pair_1h_break", False)):
                self._lock_pair_safe(pair, datetime.now(timezone.utc) + timedelta(minutes=self.post_exit_lock_min), "post_exit_lock_1hbreak")
                return "x_1h_trend_break"

            # (B) 시장 레짐 risk-off 전환 감지 → 엔트리 타입별 우선 청산
            if bool(last.get("btc_riskoff_switch", False)) or (not bool(last.get("btc_risk_on", False))):
                if tag.startswith(("TB_", "TP_")):
                    self._lock_pair_safe(pair, datetime.now(timezone.utc) + timedelta(minutes=self.post_exit_lock_min), "post_exit_lock_mktriskoff")
                    return "x_mkt_risk_off"
                # MR은 즉시 급탈출보단 조건부(변동성/시간)
                if tag.startswith("MR_") and (bool(last.get("btc_vol_spike", False)) or bool(last.get("vol_spike_pair", False))):
                    self._lock_pair_safe(pair, datetime.now(timezone.utc) + timedelta(minutes=self.post_exit_lock_min), "post_exit_lock_mr_vol")
                    return "x_mr_vol_riskoff"

            # (C) 레짐 전환(ADX 급락 등): 추세 엔트리는 추세 소멸 시 방어
            if tag.startswith(("TB_", "TP_")) and bool(last.get("trend_to_range_switch", False)):
                # 이익이 미미하면 우선 정리
                if float(current_profit) < 0.015:
                    self._lock_pair_safe(pair, datetime.now(timezone.utc) + timedelta(minutes=self.post_exit_lock_min), "post_exit_lock_trendfade")
                    return "x_trend_fade"

            # (D) 시간 언클로그: 6h 이상 + 수익 미미
            if trade.open_date_utc is not None:
                age_h = (current_time - trade.open_date_utc).total_seconds() / 3600.0
                if age_h >= float(self.unclog_hours) and abs(float(current_profit)) <= float(self.unclog_profit_band):
                    self._lock_pair_safe(pair, datetime.now(timezone.utc) + timedelta(minutes=self.post_exit_lock_min), "post_exit_lock_unclog")
                    return "x_time_unclog"

            # (E) 평균회귀 포지션: 과열/채널 상단 청산
            if tag.startswith("MR_"):
                if (float(last.get("close", 0.0)) > float(last.get("bb_upper", 1e18))) and (float(last.get("rsi", 0.0)) >= float(self.mr_exit_rsi)):
                    self._lock_pair_safe(pair, datetime.now(timezone.utc) + timedelta(minutes=self.post_exit_lock_min), "post_exit_lock_mr_heat")
                    return "x_mr_heat"

            # (F) 과도 변동성 급등(개별) 시: 특정 엔트리 우선 정리
            if bool(last.get("vol_spike_pair", False)):
                if tag.startswith("MR_") and float(current_profit) < 0.02:
                    self._lock_pair_safe(pair, datetime.now(timezone.utc) + timedelta(minutes=self.post_exit_lock_min), "post_exit_lock_mr_volspike")
                    return "x_mr_vol_spike"

            return None
        except Exception:
            return None